#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, zlib

DATA_SIZE = 1375

class Sender:
    def __init__(self, host, port):
        self.host = host
        self.remote_port = int(port)
        self.log("Sender starting up using port %s" % self.remote_port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))

        self.waiting = False # Defines if our sender needs to wait to send a packet or not

        self.window =  4 # window represents the maximum number of packets allowed in the network at one time, initilizes to 4
        self.curr_packets = 0 # this is a dynamic counter that continuously counts how many packets are in the network 

        self.send_sequence = 0 # sequence number for sending messages 

        self.recv_acks = [] # Keeps a log of all acks that were sent to the sender
        self.ack_table = [] # T/F - Indication if the packet was recieved correctly

        self.packet_log = [] # Keeps a copy of all packets that we send out

        self.rtt_log = [] # Keeps a log of all messages sent by the sender
        self.rtt = 1 # Estimate of the rtt of a packet, initilizes to 1

    # Logs a message for our sender
    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    # Sends a message
    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.host, self.remote_port))
        self.curr_packets += 1

    # Main Loop
    def run(self):
        while True:
            sockets = [self.socket, sys.stdin] if not self.waiting else [self.socket]
            socks = select.select(sockets, [], [], 0.1)[0]
            for conn in socks:

                # if we are receiving an message 
                if conn == self.socket:
                    k, addr = conn.recvfrom(65535)
                    try:
                        msg = k.decode('utf-8')
                        msg_dict = json.loads(msg)

                        # if we haven't received the ack before 
                        if msg_dict["seq"] not in self.recv_acks:
                            self.log("Received message '%s'" % msg)
                            # Set that the message has been correctly ack'd 
                            self.ack_table[msg_dict["seq"]] = True
                            # Modify the RTT based on the most recent packet to come in (80/20)
                            new_rtt = time.time() - self.rtt_log[msg_dict["seq"]]
                            weighted_new_rtt = 0.2 * new_rtt
                            weigted_curr_rtt = 0.8 * self.rtt
                            self.rtt = weighted_new_rtt + weigted_curr_rtt
                            # Modify the window size since successful transmission
                            self.window += 1
                            # we recieved an ack for a complete transmission, so decrement the number of packets currently in the network 
                            self.curr_packets -= 1
                            # add the ack to the list of received ack's
                            self.recv_acks.append(msg_dict["seq"]) 
                    except:
                        # If we hit this, we know there was an error so ignore the message
                        break   

                # if we are sending 
                elif conn == sys.stdin:
                    data = sys.stdin.read(DATA_SIZE)
                    # if no more data and no packets in the network then exit
                    if len(data) == 0 and (self.curr_packets == 0):
                        self.log("All done!")                         
                        sys.exit(0)
                    # if more data needs to be sent   
                    elif (len(data) != 0):
                        # Send a message
                        msg = {"type": "msg", "seq": self.send_sequence, "data": data, "checksum": zlib.crc32(str.encode(data))}
                        self.log("Sending message '%s'" % msg)
                        self.send(msg)
                        self.send_sequence += 1
                        # init ack'd list for specific ack to false 
                        self.ack_table.append(False)
                        # save a copy of the sent message 
                        self.packet_log.append(msg)
                        # this gets the start time of when the message was sent 
                        self.rtt_log.append(time.time())

            # See if there are packets that need to be retransmitted            
            for i in range(len(self.ack_table)):
                if(time.time() - self.rtt_log[i] >= self.rtt * 2) and not self.ack_table[i]:
                    # because we know a packet has been dropped, 
                    #   we can decrement the number of packets currently in the network 
                    self.curr_packets -= 1
                    # Log the new time
                    self.send(self.packet_log[i])
                    self.rtt_log[i] = time.time()
                    self.log("Resending message '%s'" % self.packet_log[i])
                    # Modify the window size since transmission fail
                    self.window = math.ceil(self.window / 2)

            # Determines if we need to wait or not based on packets in the network                
            if self.curr_packets < self.window:
                self.waiting = False
            else:
                self.waiting = True
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('host', type=str, help="Remote host to connect to")
    parser.add_argument('port', type=int, help="UDP port number to connect to")
    args = parser.parse_args()
    sender = Sender(args.host, args.port)
    sender.run()
