#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math, zlib

class Receiver:
    def __init__(self):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('0.0.0.0', 0))
        self.port = self.socket.getsockname()[1]
        self.log("Bound to port %d" % self.port)

        self.remote_host = None
        self.remote_port = None

        self.ack_recv_sequence = 0
        
        self.buffer = []
        self.print_count = 0

        self.recv_msg = []

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), (self.remote_host, self.remote_port))

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def flush_buffer(self):
        sys.stderr.write("-----------BUFFER----------- \n")
        for n in self.buffer:
            sys.stderr.write(str(n["seq"]) + ", ")
        sys.stderr.write("\n ---------------------------- \n")
        sys.stderr.flush()

    def run(self):
        while True:
            socks = select.select([self.socket], [], [])[0]
            for conn in socks:
                data, addr = conn.recvfrom(65535)

                # Grab the remote host/port if we don't alreadt have it
                if self.remote_host is None:
                    self.remote_host = addr[0]
                    self.remote_port = addr[1]

                # msg = type, seq, data 
                msg = json.loads(data.decode('utf-8'))
                self.log("------ RECIEVED A NEW PACKET " + str(msg["seq"]))
                # Assuming the message is not corrupted, then ... 
                if msg["checksum"] == zlib.crc32(msg["data"]):
                    # upon receiving a message, send an ack message
                    self.send({"type": "ack", "seq": msg["seq"]})
                    # Add all messages to a list, eventually print out entries of list in sequence order
                    # if we have already seen this message, then the repeated message indicates a dropped ack  
                    if msg not in self.recv_msg: 
                        if int(msg["seq"]) >= self.print_count:
                            self.buffer.append(msg)
                            self.buffer.sort(key=lambda x: x["seq"])
                            self.flush_buffer()
                            self.recv_msg.append(msg)
            
            # print logic 
            # for entry in self.buffer:
            #     if entry["seq"] == self.print_count :
            #         print(entry["data"], end='', flush=True)
            #         self.print_count += 1

            ###### OPTIMIZED ^^^^ ########
            while self.buffer:
                entry = self.buffer[0]
                if(entry["seq"] == self.print_count):  
                    print(entry["data"], end='', flush=True)             
                    self.print_count += 1
                    self.buffer.remove(self.buffer[0])
                else:
                    break

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='receive data')
    args = parser.parse_args()
    sender = Receiver()
    sender.run()
